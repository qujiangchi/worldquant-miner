\chapter{第一代架构：consultant-templates-ollama 系统}
\label{chap:gen1}

\section{概述}

第一代系统，实现于 \texttt{generation\_one/consultant-templates-ollama}，代表了一个结合AI驱动的模板生成与并发模拟测试的复杂Alpha挖掘平台。本章提供其架构、模块和实现细节的全面分析。

\section{系统架构}

\subsection{高层设计}

系统遵循模块化架构，包含以下关键组件：

\begin{itemize}
    \item \textbf{模板生成器}：使用Ollama进行AI驱动的Alpha表达式生成
    \item \textbf{多臂老虎机}：探索-利用优化
    \item \textbf{并发模拟器}：使用ThreadPoolExecutor进行并行执行
    \item \textbf{进度跟踪器}：状态持久化和恢复功能
    \item \textbf{角色系统}：用于多样化模板生成的动态AI角色
    \item \textbf{Alpha分类器}：基于性能的Alpha分类
\end{itemize}

\subsection{架构图}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.5cm and 2cm,
    box/.style={rectangle, draw=blue!50, fill=blue!10, thick, minimum width=3cm, minimum height=1cm, text centered, rounded corners},
    process/.style={rectangle, draw=green!50, fill=green!10, thick, minimum width=2.5cm, minimum height=0.8cm, text centered},
    data/.style={ellipse, draw=orange!50, fill=orange!10, thick, minimum width=2cm, minimum height=1cm, text centered},
    arrow/.style={->, >=stealth, thick}
]
    % Main components
    \node[box] (ollama) {Ollama AI\\Generator};
    \node[box, right=of ollama] (bandit) {Multi-Arm\\Bandit};
    \node[box, below=of ollama] (persona) {Persona\\System};
    \node[box, right=of persona] (validator) {Template\\Validator};
    
    % Execution layer
    \node[process, below=of persona, yshift=-0.5cm] (executor) {ThreadPool\\Executor};
    \node[process, right=of executor] (simulator) {Concurrent\\Simulator};
    
    % Data and results
    \node[data, below=of executor, yshift=-0.5cm] (wqapi) {WorldQuant\\Brain API};
    \node[data, right=of wqapi] (results) {Results\\Storage};
    
    % Progress tracking
    \node[box, below=of wqapi, yshift=-0.5cm] (tracker) {Progress\\Tracker};
    \node[box, right=of tracker] (classifier) {Alpha\\Classifier};
    
    % Arrows
    \draw[arrow] (persona) -> (ollama);
    \draw[arrow] (bandit) -> (ollama);
    \draw[arrow] (ollama) -> (validator);
    \draw[arrow] (validator) -> (executor);
    \draw[arrow] (executor) -> (simulator);
    \draw[arrow] (simulator) -> (wqapi);
    \draw[arrow] (wqapi) -> (results);
    \draw[arrow] (results) -> (tracker);
    \draw[arrow] (results) -> (classifier);
    \draw[arrow] (classifier) -> (bandit);
    \draw[arrow] (tracker) -> (bandit);
    
    % Feedback loop
    \draw[arrow, dashed, bend right=30] (classifier) to node[above, sloped] {Feedback} (persona);
\end{tikzpicture}
\caption{第一代系统架构}
\label{fig:gen1-arch}
\end{figure}

\section{核心模块}

\subsection{EnhancedTemplateGeneratorV2 类}

协调整个Alpha挖掘过程的主类。

\subsubsection{初始化}

\begin{lstlisting}[language=Python, caption=类初始化]
class EnhancedTemplateGeneratorV2:
    def __init__(self, credentials_path: str, 
                 ollama_model: str = "qwen2.5-coder:latest", 
                 max_concurrent: int = 8,
                 progress_file: str = "template_progress_v2.json",
                 results_file: str = "enhanced_results_v2.json"):
        """Initialize the enhanced template generator"""
        self.sess = requests.Session()
        self.credentials_path = credentials_path
        self.ollama_model = ollama_model
        self.ollama_url = "http://127.0.0.1:11434"
        self.max_concurrent = min(max_concurrent, 8)  # WQ limit
        self.progress_file = progress_file
        self.results_file = results_file
        self.progress_tracker = ProgressTracker()
        self.bandit = MultiArmBandit(exploration_rate=0.3)
        
        # ThreadPoolExecutor for concurrent execution
        self.executor = ThreadPoolExecutor(max_workers=self.max_concurrent)
        self.active_futures = {}
        
        # Smart slot plan: [explore, exploit, explore, exploit, ...]
        self.slot_plans = ['explore', 'exploit', 'explore', 'exploit', 
                          'explore', 'exploit', 'explore', 'exploit']
        self.slot_plan_index = 0
        
        # Region configurations
        self.region_configs = {
            "USA": RegionConfig("USA", "TOP3000", 1),
            "GLB": RegionConfig("GLB", "TOP3000", 1),
            "EUR": RegionConfig("EUR", "TOP2500", 1),
            "ASI": RegionConfig("ASI", "MINVOL1M", 1, max_trade=True),
            "CHN": RegionConfig("CHN", "TOP2000U", 1, max_trade=True)
        }
        
        self.setup_auth()
\end{lstlisting}

\subsubsection{关键特性}

\begin{enumerate}
    \item \textbf{并发执行}：使用ThreadPoolExecutor实现真正的并行模拟
    \item \textbf{智能槽位规划}：在探索和利用之间交替
    \item \textbf{进度持久化}：保存状态以实现恢复功能
    \item \textbf{操作符黑名单}：防止过度使用有问题的操作符
    \item \textbf{角色系统}：用于多样化生成的多个AI角色
\end{enumerate}

\subsection{多臂老虎机模块}

老虎机系统平衡探索和利用：

\begin{lstlisting}[language=Python, caption=多臂老虎机实现]
class MultiArmBandit:
    def __init__(self, exploration_rate: float = 0.3, 
                 decay_rate: float = 0.001, 
                 decay_interval: int = 100):
        self.exploration_rate = exploration_rate
        self.decay_rate = decay_rate
        self.decay_interval = decay_interval
        self.arm_stats = {}  # Track performance per arm
        self.total_pulls = 0
        
    def select_arm(self, arms: List[str]) -> str:
        """Select arm using epsilon-greedy strategy"""
        if random.random() < self.exploration_rate:
            # Exploration: random selection
            return random.choice(arms)
        else:
            # Exploitation: best performing arm
            return max(arms, key=lambda a: self.arm_stats.get(a, {}).get('avg_reward', 0))
    
    def update_arm(self, arm: str, reward: float):
        """Update arm statistics"""
        if arm not in self.arm_stats:
            self.arm_stats[arm] = {'pulls': 0, 'total_reward': 0, 'avg_reward': 0}
        
        stats = self.arm_stats[arm]
        stats['pulls'] += 1
        stats['total_reward'] += reward
        stats['avg_reward'] = stats['total_reward'] / stats['pulls']
        self.total_pulls += 1
        
        # Decay exploration rate
        if self.total_pulls % self.decay_interval == 0:
            self.exploration_rate *= (1 - self.decay_rate)
\end{lstlisting}

\subsection{角色系统}

用于生成多样化Alpha表达式的动态AI角色：

\begin{lstlisting}[language=Python, caption=角色老虎机系统]
class PersonaBandit:
    """Multi-arm bandit for persona selection"""
    
    def __init__(self, exploration_rate: float = 0.4):
        self.exploration_rate = exploration_rate
        self.persona_stats = {}  # {persona_id: PersonaPerformance}
        
    def add_persona(self, persona_id: str, name: str, style: str):
        """Add a new persona to the bandit"""
        if persona_id not in self.persona_stats:
            self.persona_stats[persona_id] = PersonaPerformance(
                persona_id=persona_id,
                name=name,
                style=style
            )
    
    def select_persona(self) -> dict:
        """Select persona using Thompson Sampling"""
        if random.random() < self.exploration_rate:
            # Exploration: random persona
            return random.choice(list(self.personas.values()))
        else:
            # Exploitation: best performing persona
            best_persona = max(self.persona_stats.values(), 
                             key=lambda p: p.performance_score)
            return self.personas[best_persona.persona_id]
    
    def update_persona_performance(self, persona_id: str, 
                                   alpha_result: AlphaResult):
        """Update persona statistics based on alpha performance"""
        if persona_id in self.persona_stats:
            stats = self.persona_stats[persona_id]
            stats.total_uses += 1
            if alpha_result.success:
                stats.successful_alphas += 1
                if alpha_result.color == "green":
                    stats.green_alphas += 1
                elif alpha_result.color == "yellow":
                    stats.yellow_alphas += 1
                else:
                    stats.red_alphas += 1
                
                # Update averages
                stats.avg_sharpe = (stats.avg_sharpe * (stats.successful_alphas - 1) + 
                                  alpha_result.sharpe) / stats.successful_alphas
                
            stats.success_rate = stats.successful_alphas / stats.total_uses
            stats.performance_score = (stats.success_rate * 0.4 + 
                                     stats.avg_sharpe * 0.6)
\end{lstlisting}

\subsection{使用Ollama的模板生成}

使用本地Ollama模型进行AI驱动的模板生成：

\begin{lstlisting}[language=Python, caption=Ollama API集成]
def call_ollama_api(self, prompt: str, max_retries: int = 3) -> Optional[str]:
    """Call Ollama API to generate templates"""
    blacklisted_operators = self.load_operator_blacklist()
    
    system_prompt = """You are a revolutionary quantitative finance AI that 
    BREAKS CONVENTIONAL PATTERNS and creates INNOVATIVE alpha expressions.
    
    INNOVATION MANDATE:
    - DO NOT repeat common patterns
    - PUSH BOUNDARIES and explore UNCONVENTIONAL combinations
    - Think like a DISRUPTIVE QUANT
    - Use UNEXPECTED operator combinations
    
    CREATIVITY RULES:
    1. Use ONLY the operators provided
    2. Use ONLY the data fields provided
    3. Use proper function syntax: operator(field1, field2, parameter)
    4. NO template placeholders
    5. NO SQL queries
    """
    
    for attempt in range(max_retries):
        try:
            response = ollama.generate(
                model=self.ollama_model,
                prompt=prompt,
                system=system_prompt,
                options={
                    'temperature': 0.9,  # High creativity
                    'top_p': 0.95,
                    'top_k': 40
                }
            )
            return response['response']
        except Exception as e:
            logger.warning(f"Ollama API call failed (attempt {attempt+1}): {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Exponential backoff
    
    return None
\end{lstlisting}

\subsection{并发模拟引擎}

使用ThreadPoolExecutor实现真正的并发执行：

\begin{lstlisting}[language=Python, caption=并发模拟]
def simulate_template_concurrent(self, template: str, region: str, 
                                settings: SimulationSettings) -> TemplateResult:
    """Submit simulation using ThreadPoolExecutor"""
    
    def run_simulation():
        """Inner function for thread execution"""
        try:
            # Rate limiting
            time_since_last_call = time.time() - self.last_api_call_time
            if time_since_last_call < self.api_call_interval:
                time.sleep(self.api_call_interval - time_since_last_call)
            
            self.last_api_call_time = time.time()
            
            # Submit simulation
            response = self.submit_simulation(template, region, settings)
            
            if response.status_code == 201:
                sim_id = response.json().get('id')
                # Poll for results
                result = self.poll_simulation_result(sim_id)
                return result
            else:
                return TemplateResult(
                    template=template,
                    region=region,
                    settings=settings,
                    success=False,
                    error_message=f"API error: {response.status_code}"
                )
        except Exception as e:
            logger.error(f"Simulation error: {e}")
            return TemplateResult(
                template=template,
                region=region,
                settings=settings,
                success=False,
                error_message=str(e)
            )
    
    # Submit to thread pool
    future = self.executor.submit(run_simulation)
    self.active_futures[future] = {
        'template': template,
        'region': region,
        'start_time': time.time()
    }
    
    return future
\end{lstlisting}

\subsection{进度跟踪系统}

用于恢复功能的状态持久化：

\begin{lstlisting}[language=Python, caption=进度跟踪]
class ProgressTracker:
    def __init__(self):
        self.total_templates = 0
        self.completed_simulations = 0
        self.successful_simulations = 0
        self.failed_simulations = 0
        self.best_sharpe = 0.0
        self.best_template = None
        
    def update(self, result: TemplateResult):
        """Update progress statistics"""
        self.completed_simulations += 1
        
        if result.success:
            self.successful_simulations += 1
            if result.sharpe > self.best_sharpe:
                self.best_sharpe = result.sharpe
                self.best_template = result.template
        else:
            self.failed_simulations += 1
    
    def save_progress(self, filepath: str):
        """Save progress to JSON file"""
        progress_data = {
            'total_templates': self.total_templates,
            'completed_simulations': self.completed_simulations,
            'successful_simulations': self.successful_simulations,
            'failed_simulations': self.failed_simulations,
            'best_sharpe': self.best_sharpe,
            'best_template': self.best_template,
            'timestamp': time.time()
        }
        with open(filepath, 'w') as f:
            json.dump(progress_data, f, indent=2)
    
    def load_progress(self, filepath: str):
        """Load progress from JSON file"""
        if os.path.exists(filepath):
            with open(filepath, 'r') as f:
                data = json.load(f)
                self.total_templates = data.get('total_templates', 0)
                self.completed_simulations = data.get('completed_simulations', 0)
                self.successful_simulations = data.get('successful_simulations', 0)
                self.failed_simulations = data.get('failed_simulations', 0)
                self.best_sharpe = data.get('best_sharpe', 0.0)
                self.best_template = data.get('best_template', None)
\end{lstlisting}

\section{数据结构}

\subsection{AlphaResult}

\begin{lstlisting}[language=Python, caption=Alpha结果数据结构]
@dataclass
class AlphaResult:
    """Track alpha performance and color classification"""
    template: str
    region: str
    sharpe: float
    margin: float
    turnover: float
    returns: float
    drawdown: float
    fitness: float
    color: str  # "green", "yellow", "red"
    timestamp: float
    persona_used: str
    success: bool = True
\end{lstlisting}

\subsection{RegionConfig}

\begin{lstlisting}[language=Python, caption=区域配置]
@dataclass
class RegionConfig:
    """Configuration for different regions"""
    region: str
    universe: str
    delay: int
    max_trade: bool = False
    neutralization_options: List[str] = None
    
    def __post_init__(self):
        if self.neutralization_options is None:
            if self.region == "USA":
                self.neutralization_options = ["INDUSTRY", "SUBINDUSTRY", 
                                              "SECTOR", "COUNTRY", "NONE"]
            # ... other regions
\end{lstlisting}

\section{关键算法}

\subsection{模板生成工作流}

\begin{algorithm}
\caption{模板生成和模拟工作流}
\begin{algorithmic}[1]
\State 使用凭证和Ollama模型初始化系统
\State 为目标区域加载操作符和数据字段
\State 使用PersonaBandit选择角色
\State 使用Ollama API和角色风格生成模板
\State 验证模板语法和字段使用
\State 使用MultiArmBandit选择区域和设置
\State 向ThreadPoolExecutor提交模拟
\State 轮询模拟结果
\State 根据性能对Alpha进行分类（绿色/黄色/红色）
\State 更新老虎机统计
\State 定期保存进度
\end{algorithmic}
\end{algorithm}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.2cm,
    process/.style={rectangle, draw=blue!50, fill=blue!10, thick, minimum width=2.5cm, minimum height=0.8cm, text centered, rounded corners},
    decision/.style={diamond, draw=red!50, fill=red!10, thick, minimum width=2cm, minimum height=1.2cm, text centered, aspect=2},
    arrow/.style={->, >=stealth, thick},
    startstop/.style={ellipse, draw=green!50, fill=green!10, thick, minimum width=2cm, minimum height=0.8cm, text centered}
]
    \node[startstop] (start) {Start};
    \node[process, below=of start] (init) {Initialize\\System};
    \node[process, below=of init] (load) {Load Operators\\\& Fields};
    \node[process, below=of load] (select) {Select Persona};
    \node[process, below=of select] (generate) {Generate\\Template};
    \node[decision, below=of generate, yshift=-0.3cm] (validate) {Valid?};
    \node[process, below=of validate, yshift=-0.3cm] (simulate) {Submit\\Simulation};
    \node[process, below=of simulate] (poll) {Poll Results};
    \node[decision, below=of poll, yshift=-0.3cm] (success) {Success?};
    \node[process, below=of success, yshift=-0.3cm] (classify) {Classify\\Alpha};
    \node[process, below=of classify] (update) {Update\\Bandit};
    \node[process, below=of update] (save) {Save Progress};
    \node[startstop, below=of save] (end) {Continue};
    
    \draw[arrow] (start) -> (init);
    \draw[arrow] (init) -> (load);
    \draw[arrow] (load) -> (select);
    \draw[arrow] (select) -> (generate);
    \draw[arrow] (generate) -> (validate);
    \draw[arrow] (validate) -> node[right] {Yes} (simulate);
    \draw[arrow] (validate) -| node[above] {No} ++(-2,0) |- (select);
    \draw[arrow] (simulate) -> (poll);
    \draw[arrow] (poll) -> (success);
    \draw[arrow] (success) -> node[right] {Yes} (classify);
    \draw[arrow] (success) -| node[above] {No} ++(2,0) |- (select);
    \draw[arrow] (classify) -> (update);
    \draw[arrow] (update) -> (save);
    \draw[arrow] (save) -> (end);
    \draw[arrow, dashed, bend left=60] (end) to (select);
\end{tikzpicture}
\caption{模板生成和模拟工作流}
\label{fig:gen1-workflow}
\end{figure}

\subsection{Alpha分类}

Alpha被分为三类：

\begin{itemize}
    \item \textbf{绿色}：Sharpe $> 1.5$，Fitness $> 1.0$，Margin $> 15$ bps
    \item \textbf{黄色}：Sharpe $> 1.25$，Fitness $> 0.8$，Margin $> 10$ bps
    \item \textbf{红色}：其他所有（但仍然是成功的模拟）
\end{itemize}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    criteria/.style={rectangle, draw=blue!50, fill=blue!10, thick, minimum width=2.5cm, minimum height=1cm, text centered, rounded corners},
    category/.style={circle, draw, thick, minimum size=2cm, text centered, font=\bfseries},
    arrow/.style={->, >=stealth, thick}
]
    % Criteria boxes
    \node[criteria] (sharpe) {Sharpe Ratio};
    \node[criteria, below=of sharpe] (fitness) {Fitness Score};
    \node[criteria, below=of fitness] (margin) {Margin (bps)};
    
    % Classification categories
    \node[category, right=of sharpe, fill=green!30] (green) {GREEN};
    \node[category, right=of fitness, fill=yellow!30] (yellow) {YELLOW};
    \node[category, right=of margin, fill=red!30] (red) {RED};
    
    % Threshold lines
    \node[left=0.5cm of green] (gthresh) {$>1.5$};
    \node[left=0.5cm of yellow] (ythresh) {$>1.25$};
    \node[left=0.5cm of red] (rthresh) {$<$};
    
    % Arrows
    \draw[arrow] (sharpe) -> (green);
    \draw[arrow] (fitness) -> (yellow);
    \draw[arrow] (margin) -> (red);
    
    % Labels
    \node[above=0.3cm of green] {\textbf{Elite}};
    \node[above=0.3cm of yellow] {\textbf{Good}};
    \node[above=0.3cm of red] {\textbf{Acceptable}};
\end{tikzpicture}
\caption{Alpha分类系统}
\label{fig:alpha-classification}
\end{figure}

\section{第一代的局限性}

\subsection{已识别的问题}

\begin{enumerate}
    \item \textbf{无自优化}：模板被生成但未进化
    \item \textbf{静态角色}：角色不根据性能适应
    \item \textbf{无遗传算法}：没有成功Alpha的交叉或变异
    \item \textbf{有限学习}：系统无法有效从失败模式中学习
    \item \textbf{无实时测试}：所有测试都在生成后发生
    \item \textbf{无质量跟踪}：Alpha未监控退化
    \item \textbf{固定探索率}：老虎机探索率不动态适应
\end{enumerate}

\subsection{性能瓶颈}

\begin{itemize}
    \item API速率限制（每分钟30个请求）
    \item 顺序模板生成（Ollama调用）
    \item 无成功模式缓存
    \item AI生成的并行化有限
\end{itemize}

\section{代码片段用于重建}

\subsection{完整初始化示例}

\begin{lstlisting}[language=Python, caption=完整系统初始化]
# Initialize the generator
generator = EnhancedTemplateGeneratorV2(
    credentials_path='credential.txt',
    ollama_model='qwen2.5-coder:latest',
    max_concurrent=8,
    progress_file='template_progress_v2.json',
    results_file='enhanced_results_v2.json'
)

# Generate and test templates
results = generator.generate_and_test_templates(
    regions=['USA', 'GLB', 'EUR', 'ASI', 'CHN'],
    templates_per_region=10,
    resume=False,
    max_iterations=None  # Run indefinitely
)

# Save final results
generator.save_results(results, 'enhanced_results_v2.json')
\end{lstlisting}

\subsection{区域特定生成}

\begin{lstlisting}[language=Python, caption=区域特定模板生成]
def generate_for_region(self, region: str, num_templates: int):
    """Generate templates for a specific region"""
    config = self.region_configs[region]
    fields = self.get_data_fields(region, config.universe, config.delay)
    operators = self.load_operators()
    
    templates = []
    for i in range(num_templates):
        # Select persona
        persona = self.persona_bandit.select_persona()
        
        # Generate template
        template = self.generate_template_with_persona(
            persona, operators, fields, region
        )
        
        if template:
            templates.append(template)
    
    return templates
\end{lstlisting}

\section{总结}

第一代建立了坚实的基础，包括：
\begin{itemize}
    \item AI驱动的模板生成
    \item 并发模拟测试
    \item 多臂老虎机优化
    \item 进度持久化
    \item 基于角色的多样性
\end{itemize}

然而，它缺乏自优化、遗传进化和自适应学习能力，这些将在第二代中解决。
