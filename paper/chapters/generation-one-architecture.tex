\chapter{Generation One Architecture: consultant-templates-ollama System}
\label{chap:gen1}

\section{Overview}

The Generation One system, implemented in \texttt{generation\_one/consultant-templates-ollama}, represents a sophisticated alpha mining platform that combines AI-powered template generation with concurrent simulation testing. This chapter provides a comprehensive analysis of its architecture, modules, and implementation details.

\section{System Architecture}

\subsection{High-Level Design}

The system follows a modular architecture with the following key components:

\begin{itemize}
    \item \textbf{Template Generator}: AI-powered alpha expression generation using Ollama
    \item \textbf{Multi-Arm Bandit}: Exploration-exploitation optimization
    \item \textbf{Concurrent Simulator}: Parallel execution using ThreadPoolExecutor
    \item \textbf{Progress Tracker}: State persistence and resume functionality
    \item \textbf{Persona System}: Dynamic AI personas for diverse template generation
    \item \textbf{Alpha Classifier}: Performance-based alpha categorization
\end{itemize}

\subsection{Architecture Diagram}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.5cm and 2cm,
    box/.style={rectangle, draw=blue!50, fill=blue!10, thick, minimum width=3cm, minimum height=1cm, text centered, rounded corners},
    process/.style={rectangle, draw=green!50, fill=green!10, thick, minimum width=2.5cm, minimum height=0.8cm, text centered},
    data/.style={ellipse, draw=orange!50, fill=orange!10, thick, minimum width=2cm, minimum height=1cm, text centered},
    arrow/.style={->, >=stealth, thick}
]
    % Main components
    \node[box] (ollama) {Ollama AI\\Generator};
    \node[box, right=of ollama] (bandit) {Multi-Arm\\Bandit};
    \node[box, below=of ollama] (persona) {Persona\\System};
    \node[box, right=of persona] (validator) {Template\\Validator};
    
    % Execution layer
    \node[process, below=of persona, yshift=-0.5cm] (executor) {ThreadPool\\Executor};
    \node[process, right=of executor] (simulator) {Concurrent\\Simulator};
    
    % Data and results
    \node[data, below=of executor, yshift=-0.5cm] (wqapi) {WorldQuant\\Brain API};
    \node[data, right=of wqapi] (results) {Results\\Storage};
    
    % Progress tracking
    \node[box, below=of wqapi, yshift=-0.5cm] (tracker) {Progress\\Tracker};
    \node[box, right=of tracker] (classifier) {Alpha\\Classifier};
    
    % Arrows
    \draw[arrow] (persona) -> (ollama);
    \draw[arrow] (bandit) -> (ollama);
    \draw[arrow] (ollama) -> (validator);
    \draw[arrow] (validator) -> (executor);
    \draw[arrow] (executor) -> (simulator);
    \draw[arrow] (simulator) -> (wqapi);
    \draw[arrow] (wqapi) -> (results);
    \draw[arrow] (results) -> (tracker);
    \draw[arrow] (results) -> (classifier);
    \draw[arrow] (classifier) -> (bandit);
    \draw[arrow] (tracker) -> (bandit);
    
    % Feedback loop
    \draw[arrow, dashed, bend right=30] (classifier) to node[above, sloped] {Feedback} (persona);
\end{tikzpicture}
\caption{Generation One System Architecture}
\label{fig:gen1-arch}
\end{figure}

\section{Core Modules}

\subsection{EnhancedTemplateGeneratorV2 Class}

The main class orchestrating the entire alpha mining process.

\subsubsection{Initialization}

\begin{lstlisting}[language=Python, caption=Class Initialization]
class EnhancedTemplateGeneratorV2:
    def __init__(self, credentials_path: str, 
                 ollama_model: str = "qwen2.5-coder:latest", 
                 max_concurrent: int = 8,
                 progress_file: str = "template_progress_v2.json",
                 results_file: str = "enhanced_results_v2.json"):
        """Initialize the enhanced template generator"""
        self.sess = requests.Session()
        self.credentials_path = credentials_path
        self.ollama_model = ollama_model
        self.ollama_url = "http://127.0.0.1:11434"
        self.max_concurrent = min(max_concurrent, 8)  # WQ limit
        self.progress_file = progress_file
        self.results_file = results_file
        self.progress_tracker = ProgressTracker()
        self.bandit = MultiArmBandit(exploration_rate=0.3)
        
        # ThreadPoolExecutor for concurrent execution
        self.executor = ThreadPoolExecutor(max_workers=self.max_concurrent)
        self.active_futures = {}
        
        # Smart slot plan: [explore, exploit, explore, exploit, ...]
        self.slot_plans = ['explore', 'exploit', 'explore', 'exploit', 
                          'explore', 'exploit', 'explore', 'exploit']
        self.slot_plan_index = 0
        
        # Region configurations
        self.region_configs = {
            "USA": RegionConfig("USA", "TOP3000", 1),
            "GLB": RegionConfig("GLB", "TOP3000", 1),
            "EUR": RegionConfig("EUR", "TOP2500", 1),
            "ASI": RegionConfig("ASI", "MINVOL1M", 1, max_trade=True),
            "CHN": RegionConfig("CHN", "TOP2000U", 1, max_trade=True)
        }
        
        self.setup_auth()
\end{lstlisting}

\subsubsection{Key Features}

\begin{enumerate}
    \item \textbf{Concurrent Execution}: Uses ThreadPoolExecutor for true parallel simulation
    \item \textbf{Smart Slot Planning}: Alternates between exploration and exploitation
    \item \textbf{Progress Persistence}: Saves state for resume functionality
    \item \textbf{Operator Blacklisting}: Prevents overuse of problematic operators
    \item \textbf{Persona System}: Multiple AI personas for diverse generation
\end{enumerate}

\subsection{Multi-Arm Bandit Module}

The bandit system balances exploration and exploitation:

\begin{lstlisting}[language=Python, caption=Multi-Arm Bandit Implementation]
class MultiArmBandit:
    def __init__(self, exploration_rate: float = 0.3, 
                 decay_rate: float = 0.001, 
                 decay_interval: int = 100):
        self.exploration_rate = exploration_rate
        self.decay_rate = decay_rate
        self.decay_interval = decay_interval
        self.arm_stats = {}  # Track performance per arm
        self.total_pulls = 0
        
    def select_arm(self, arms: List[str]) -> str:
        """Select arm using epsilon-greedy strategy"""
        if random.random() < self.exploration_rate:
            # Exploration: random selection
            return random.choice(arms)
        else:
            # Exploitation: best performing arm
            return max(arms, key=lambda a: self.arm_stats.get(a, {}).get('avg_reward', 0))
    
    def update_arm(self, arm: str, reward: float):
        """Update arm statistics"""
        if arm not in self.arm_stats:
            self.arm_stats[arm] = {'pulls': 0, 'total_reward': 0, 'avg_reward': 0}
        
        stats = self.arm_stats[arm]
        stats['pulls'] += 1
        stats['total_reward'] += reward
        stats['avg_reward'] = stats['total_reward'] / stats['pulls']
        self.total_pulls += 1
        
        # Decay exploration rate
        if self.total_pulls % self.decay_interval == 0:
            self.exploration_rate *= (1 - self.decay_rate)
\end{lstlisting}

\subsection{Persona System}

Dynamic AI personas for generating diverse alpha expressions:

\begin{lstlisting}[language=Python, caption=Persona Bandit System]
class PersonaBandit:
    """Multi-arm bandit for persona selection"""
    
    def __init__(self, exploration_rate: float = 0.4):
        self.exploration_rate = exploration_rate
        self.persona_stats = {}  # {persona_id: PersonaPerformance}
        
    def add_persona(self, persona_id: str, name: str, style: str):
        """Add a new persona to the bandit"""
        if persona_id not in self.persona_stats:
            self.persona_stats[persona_id] = PersonaPerformance(
                persona_id=persona_id,
                name=name,
                style=style
            )
    
    def select_persona(self) -> dict:
        """Select persona using Thompson Sampling"""
        if random.random() < self.exploration_rate:
            # Exploration: random persona
            return random.choice(list(self.personas.values()))
        else:
            # Exploitation: best performing persona
            best_persona = max(self.persona_stats.values(), 
                             key=lambda p: p.performance_score)
            return self.personas[best_persona.persona_id]
    
    def update_persona_performance(self, persona_id: str, 
                                   alpha_result: AlphaResult):
        """Update persona statistics based on alpha performance"""
        if persona_id in self.persona_stats:
            stats = self.persona_stats[persona_id]
            stats.total_uses += 1
            if alpha_result.success:
                stats.successful_alphas += 1
                if alpha_result.color == "green":
                    stats.green_alphas += 1
                elif alpha_result.color == "yellow":
                    stats.yellow_alphas += 1
                else:
                    stats.red_alphas += 1
                
                # Update averages
                stats.avg_sharpe = (stats.avg_sharpe * (stats.successful_alphas - 1) + 
                                  alpha_result.sharpe) / stats.successful_alphas
                
            stats.success_rate = stats.successful_alphas / stats.total_uses
            stats.performance_score = (stats.success_rate * 0.4 + 
                                     stats.avg_sharpe * 0.6)
\end{lstlisting}

\subsection{Template Generation with Ollama}

AI-powered template generation using local Ollama models:

\begin{lstlisting}[language=Python, caption=Ollama API Integration]
def call_ollama_api(self, prompt: str, max_retries: int = 3) -> Optional[str]:
    """Call Ollama API to generate templates"""
    blacklisted_operators = self.load_operator_blacklist()
    
    system_prompt = """You are a revolutionary quantitative finance AI that 
    BREAKS CONVENTIONAL PATTERNS and creates INNOVATIVE alpha expressions.
    
    INNOVATION MANDATE:
    - DO NOT repeat common patterns
    - PUSH BOUNDARIES and explore UNCONVENTIONAL combinations
    - Think like a DISRUPTIVE QUANT
    - Use UNEXPECTED operator combinations
    
    CREATIVITY RULES:
    1. Use ONLY the operators provided
    2. Use ONLY the data fields provided
    3. Use proper function syntax: operator(field1, field2, parameter)
    4. NO template placeholders
    5. NO SQL queries
    """
    
    for attempt in range(max_retries):
        try:
            response = ollama.generate(
                model=self.ollama_model,
                prompt=prompt,
                system=system_prompt,
                options={
                    'temperature': 0.9,  # High creativity
                    'top_p': 0.95,
                    'top_k': 40
                }
            )
            return response['response']
        except Exception as e:
            logger.warning(f"Ollama API call failed (attempt {attempt+1}): {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Exponential backoff
    
    return None
\end{lstlisting}

\subsection{Concurrent Simulation Engine}

True concurrent execution using ThreadPoolExecutor:

\begin{lstlisting}[language=Python, caption=Concurrent Simulation]
def simulate_template_concurrent(self, template: str, region: str, 
                                settings: SimulationSettings) -> TemplateResult:
    """Submit simulation using ThreadPoolExecutor"""
    
    def run_simulation():
        """Inner function for thread execution"""
        try:
            # Rate limiting
            time_since_last_call = time.time() - self.last_api_call_time
            if time_since_last_call < self.api_call_interval:
                time.sleep(self.api_call_interval - time_since_last_call)
            
            self.last_api_call_time = time.time()
            
            # Submit simulation
            response = self.submit_simulation(template, region, settings)
            
            if response.status_code == 201:
                sim_id = response.json().get('id')
                # Poll for results
                result = self.poll_simulation_result(sim_id)
                return result
            else:
                return TemplateResult(
                    template=template,
                    region=region,
                    settings=settings,
                    success=False,
                    error_message=f"API error: {response.status_code}"
                )
        except Exception as e:
            logger.error(f"Simulation error: {e}")
            return TemplateResult(
                template=template,
                region=region,
                settings=settings,
                success=False,
                error_message=str(e)
            )
    
    # Submit to thread pool
    future = self.executor.submit(run_simulation)
    self.active_futures[future] = {
        'template': template,
        'region': region,
        'start_time': time.time()
    }
    
    return future
\end{lstlisting}

\subsection{Progress Tracking System}

State persistence for resume functionality:

\begin{lstlisting}[language=Python, caption=Progress Tracking]
class ProgressTracker:
    def __init__(self):
        self.total_templates = 0
        self.completed_simulations = 0
        self.successful_simulations = 0
        self.failed_simulations = 0
        self.best_sharpe = 0.0
        self.best_template = None
        
    def update(self, result: TemplateResult):
        """Update progress statistics"""
        self.completed_simulations += 1
        
        if result.success:
            self.successful_simulations += 1
            if result.sharpe > self.best_sharpe:
                self.best_sharpe = result.sharpe
                self.best_template = result.template
        else:
            self.failed_simulations += 1
    
    def save_progress(self, filepath: str):
        """Save progress to JSON file"""
        progress_data = {
            'total_templates': self.total_templates,
            'completed_simulations': self.completed_simulations,
            'successful_simulations': self.successful_simulations,
            'failed_simulations': self.failed_simulations,
            'best_sharpe': self.best_sharpe,
            'best_template': self.best_template,
            'timestamp': time.time()
        }
        with open(filepath, 'w') as f:
            json.dump(progress_data, f, indent=2)
    
    def load_progress(self, filepath: str):
        """Load progress from JSON file"""
        if os.path.exists(filepath):
            with open(filepath, 'r') as f:
                data = json.load(f)
                self.total_templates = data.get('total_templates', 0)
                self.completed_simulations = data.get('completed_simulations', 0)
                self.successful_simulations = data.get('successful_simulations', 0)
                self.failed_simulations = data.get('failed_simulations', 0)
                self.best_sharpe = data.get('best_sharpe', 0.0)
                self.best_template = data.get('best_template', None)
\end{lstlisting}

\section{Data Structures}

\subsection{AlphaResult}

\begin{lstlisting}[language=Python, caption=Alpha Result Data Structure]
@dataclass
class AlphaResult:
    """Track alpha performance and color classification"""
    template: str
    region: str
    sharpe: float
    margin: float
    turnover: float
    returns: float
    drawdown: float
    fitness: float
    color: str  # "green", "yellow", "red"
    timestamp: float
    persona_used: str
    success: bool = True
\end{lstlisting}

\subsection{RegionConfig}

\begin{lstlisting}[language=Python, caption=Region Configuration]
@dataclass
class RegionConfig:
    """Configuration for different regions"""
    region: str
    universe: str
    delay: int
    max_trade: bool = False
    neutralization_options: List[str] = None
    
    def __post_init__(self):
        if self.neutralization_options is None:
            if self.region == "USA":
                self.neutralization_options = ["INDUSTRY", "SUBINDUSTRY", 
                                              "SECTOR", "COUNTRY", "NONE"]
            # ... other regions
\end{lstlisting}

\section{Key Algorithms}

\subsection{Template Generation Workflow}

\begin{algorithm}
\caption{Template Generation and Simulation Workflow}
\begin{algorithmic}[1]
\State Initialize system with credentials and Ollama model
\State Load operators and data fields for target region
\State Select persona using PersonaBandit
\State Generate template using Ollama API with persona style
\State Validate template syntax and field usage
\State Select region and settings using MultiArmBandit
\State Submit simulation to ThreadPoolExecutor
\State Poll for simulation results
\State Classify alpha (green/yellow/red) based on performance
\State Update bandit statistics
\State Save progress periodically
\end{algorithmic}
\end{algorithm}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.2cm,
    process/.style={rectangle, draw=blue!50, fill=blue!10, thick, minimum width=2.5cm, minimum height=0.8cm, text centered, rounded corners},
    decision/.style={diamond, draw=red!50, fill=red!10, thick, minimum width=2cm, minimum height=1.2cm, text centered, aspect=2},
    arrow/.style={->, >=stealth, thick},
    startstop/.style={ellipse, draw=green!50, fill=green!10, thick, minimum width=2cm, minimum height=0.8cm, text centered}
]
    \node[startstop] (start) {Start};
    \node[process, below=of start] (init) {Initialize\\System};
    \node[process, below=of init] (load) {Load Operators\\\& Fields};
    \node[process, below=of load] (select) {Select Persona};
    \node[process, below=of select] (generate) {Generate\\Template};
    \node[decision, below=of generate, yshift=-0.3cm] (validate) {Valid?};
    \node[process, below=of validate, yshift=-0.3cm] (simulate) {Submit\\Simulation};
    \node[process, below=of simulate] (poll) {Poll Results};
    \node[decision, below=of poll, yshift=-0.3cm] (success) {Success?};
    \node[process, below=of success, yshift=-0.3cm] (classify) {Classify\\Alpha};
    \node[process, below=of classify] (update) {Update\\Bandit};
    \node[process, below=of update] (save) {Save Progress};
    \node[startstop, below=of save] (end) {Continue};
    
    \draw[arrow] (start) -> (init);
    \draw[arrow] (init) -> (load);
    \draw[arrow] (load) -> (select);
    \draw[arrow] (select) -> (generate);
    \draw[arrow] (generate) -> (validate);
    \draw[arrow] (validate) -> node[right] {Yes} (simulate);
    \draw[arrow] (validate) -| node[above] {No} ++(-2,0) |- (select);
    \draw[arrow] (simulate) -> (poll);
    \draw[arrow] (poll) -> (success);
    \draw[arrow] (success) -> node[right] {Yes} (classify);
    \draw[arrow] (success) -| node[above] {No} ++(2,0) |- (select);
    \draw[arrow] (classify) -> (update);
    \draw[arrow] (update) -> (save);
    \draw[arrow] (save) -> (end);
    \draw[arrow, dashed, bend left=60] (end) to (select);
\end{tikzpicture}
\caption{Template Generation and Simulation Workflow}
\label{fig:gen1-workflow}
\end{figure}

\subsection{Alpha Classification}

Alphas are classified into three categories:

\begin{itemize}
    \item \textbf{Green}: Sharpe $> 1.5$, Fitness $> 1.0$, Margin $> 15$ bps
    \item \textbf{Yellow}: Sharpe $> 1.25$, Fitness $> 0.8$, Margin $> 10$ bps
    \item \textbf{Red}: All others (but still successful simulations)
\end{itemize}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    criteria/.style={rectangle, draw=blue!50, fill=blue!10, thick, minimum width=2.5cm, minimum height=1cm, text centered, rounded corners},
    category/.style={circle, draw, thick, minimum size=2cm, text centered, font=\bfseries},
    arrow/.style={->, >=stealth, thick}
]
    % Criteria boxes
    \node[criteria] (sharpe) {Sharpe Ratio};
    \node[criteria, below=of sharpe] (fitness) {Fitness Score};
    \node[criteria, below=of fitness] (margin) {Margin (bps)};
    
    % Classification categories
    \node[category, right=of sharpe, fill=green!30] (green) {GREEN};
    \node[category, right=of fitness, fill=yellow!30] (yellow) {YELLOW};
    \node[category, right=of margin, fill=red!30] (red) {RED};
    
    % Threshold lines
    \node[left=0.5cm of green] (gthresh) {$>1.5$};
    \node[left=0.5cm of yellow] (ythresh) {$>1.25$};
    \node[left=0.5cm of red] (rthresh) {$<$};
    
    % Arrows
    \draw[arrow] (sharpe) -> (green);
    \draw[arrow] (fitness) -> (yellow);
    \draw[arrow] (margin) -> (red);
    
    % Labels
    \node[above=0.3cm of green] {\textbf{Elite}};
    \node[above=0.3cm of yellow] {\textbf{Good}};
    \node[above=0.3cm of red] {\textbf{Acceptable}};
\end{tikzpicture}
\caption{Alpha Classification System}
\label{fig:alpha-classification}
\end{figure}

\section{Limitations of Generation One}

\subsection{Identified Issues}

\begin{enumerate}
    \item \textbf{No Self-Optimization}: Templates are generated but not evolved
    \item \textbf{Static Personas}: Personas don't adapt based on performance
    \item \textbf{No Genetic Algorithms}: No crossover or mutation of successful alphas
    \item \textbf{Limited Learning}: System doesn't learn from failure patterns effectively
    \item \textbf{No On-the-Fly Testing}: All testing happens post-generation
    \item \textbf{No Quality Tracking Over Time}: Alphas aren't monitored for degradation
    \item \textbf{Fixed Exploration Rate}: Bandit exploration rate doesn't adapt dynamically
\end{enumerate}

\subsection{Performance Bottlenecks}

\begin{itemize}
    \item API rate limiting (30 requests/minute)
    \item Sequential template generation (Ollama calls)
    \item No caching of successful patterns
    \item Limited parallelization of AI generation
\end{itemize}

\section{Code Snippets for Recreation}

\subsection{Complete Initialization Example}

\begin{lstlisting}[language=Python, caption=Complete System Initialization]
# Initialize the generator
generator = EnhancedTemplateGeneratorV2(
    credentials_path='credential.txt',
    ollama_model='qwen2.5-coder:latest',
    max_concurrent=8,
    progress_file='template_progress_v2.json',
    results_file='enhanced_results_v2.json'
)

# Generate and test templates
results = generator.generate_and_test_templates(
    regions=['USA', 'GLB', 'EUR', 'ASI', 'CHN'],
    templates_per_region=10,
    resume=False,
    max_iterations=None  # Run indefinitely
)

# Save final results
generator.save_results(results, 'enhanced_results_v2.json')
\end{lstlisting}

\subsection{Region-Specific Generation}

\begin{lstlisting}[language=Python, caption=Region-Specific Template Generation]
def generate_for_region(self, region: str, num_templates: int):
    """Generate templates for a specific region"""
    config = self.region_configs[region]
    fields = self.get_data_fields(region, config.universe, config.delay)
    operators = self.load_operators()
    
    templates = []
    for i in range(num_templates):
        # Select persona
        persona = self.persona_bandit.select_persona()
        
        # Generate template
        template = self.generate_template_with_persona(
            persona, operators, fields, region
        )
        
        if template:
            templates.append(template)
    
    return templates
\end{lstlisting}

\section{Summary}

Generation One establishes a solid foundation with:
\begin{itemize}
    \item AI-powered template generation
    \item Concurrent simulation testing
    \item Multi-arm bandit optimization
    \item Progress persistence
    \item Persona-based diversity
\end{itemize}

However, it lacks self-optimization, genetic evolution, and adaptive learning capabilities that will be addressed in Generation Two.

